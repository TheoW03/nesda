#include <RomUtil.h>
#include <fstream>
#include <instruction_map.h>
// #include <instruction.h>
#include <algorithm>
#include <memory>
#include <cli.h>
// #include <util.h>
#include <map>

int partition(std::vector<std::shared_ptr<instr>> &arr, int low, int high)
{
    int pivot = arr[high]->pc; // pivot
    int i = low - 1;           // index of smaller element

    for (int j = low; j < high; j++)
    {
        if (arr[j]->pc < pivot)
        {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }

    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

void qsort_pc(std::vector<std::shared_ptr<instr>> &arr, int low, int high)
{
    if (low < high)
    {
        int pi = partition(arr, low, high);

        qsort_pc(arr, low, pi - 1);
        qsort_pc(arr, pi + 1, high);
    }
}
// void sort_by_PC(std::vector<std::shared_ptr<instr>> &prg)
// {

//     for (int i = 0; i < prg.size(); i++)
//     {
//         for (int j = 0; j < prg.size() - i - 1; j++)
//         {
//             if (prg[j]->pc > prg[j + 1]->pc)
//                 std::swap(prg[j], prg[j + 1]);
//         }
//     }
// }
std::vector<std::shared_ptr<instr>> computer(DisAsmState &state)
{
    std::vector<std::shared_ptr<instr>> disassembled_rom;

    bool end = false;

    while (!end)
    {
        // disassembles labels
        // if (state.known_lables.find(state.bus.get_pc() - 1) != state.known_lables.end() //
        // && state.assembled.find(state.bus.get_pc() - 1) == state.assembled.end())
        // {
        // disassembled_rom.push_back(std::make_shared<Label>(state.known_lables[state.bus.get_pc() - 1], state.bus.get_pc() - 1));
        // state.assembled.insert(std::make_pair(state.bus.get_pc() - 1, state.known_lables[state.bus.get_pc() - 1]));
        // state.known_lables.erase(state.bus.get_pc() - 1);
        // }
        // if (state.bus.pc_visited.find(state.bus.get_pc()) != state.bus.pc_visited.end())
        // {
        //     auto new_pc = state.bus.get_next_queue();
        //     if (new_pc == 0)
        //     {
        //         // if they are no more instructions to disassemble
        //         // both in the queue and the next PC.
        //         // we assume the ROM as fully disassembled
        //         return disassembled_rom;
        //     }
        //     state.bus.fill_instr(new_pc);
        //     continue;
        // }
        if (state.is_finished)
        {

            return disassembled_rom;
        }
        auto instr = state.bus.get_instr(true);

        if (!instr.has_value() || !InstructionValid(instr.value()))
        {
            if (instr.has_value() && !InstructionValid(instr.value()))
            {
                state.bus.pc_visited.erase(state.bus.get_pc() - 2);
            }

            // if the instruction is a BRK,
            // or is inavlid
            // it checks the PC queue, generated by BNE, BEQ..
            // and all the interrupt vectors and sets the PC
            // to that address if and only if its not already disassembled

            auto new_pc = state.bus.get_next_queue();

            if (!new_pc.has_value())
            {
                // if they are no more instructions to disassemble
                // both in the queue and the next PC.
                // we assume the ROM as fully disassembled
                // state.bus.pc_visited.erase(state.bus.get_pc() - 2);
                return disassembled_rom;
            }

            state.bus.fill_instr(new_pc.value());
        }
        else
        {
            auto current_instr = GetInstruction(instr.value());
            auto disassmble = current_instr.instructionFunction(current_instr.addressmode, state, current_instr.name);
            disassembled_rom.push_back(disassmble);
        }
        // while (!state.bus.work_list.empty())
        // {
        //     state.bus.pc_visited.insert(state.bus.work_list.top());
        //     state.bus.work_list.pop();
        //     /* code */
        // }
    }
    return disassembled_rom;
}
int getHighestPC(NESRom nes)
{
    for (int i = 0xfffa - 1; i > 0x8000; i--)
    {
        if (nes.prg_rom[i - 0x8000] != 0)
        {
            return i;
        }
    }
    return 0x8000;
}
void init(NESRom nes, Output o)
{
    initializeInstructionMap();

    if (!o.output_files.has_value())
    {
        o.output_files = "./TestOutPut/Test.s";
    }

    Header h = Header(nes.header);
    uint16_t pc_start = nes.prg_rom[0xfffd - 0x8000] << 8 | nes.prg_rom[0xfffc - 0x8000];
    uint16_t nmi = nes.prg_rom[0xfffb - 0x8000] << 8 | nes.prg_rom[0xfffa - 0x8000];
    Bus bus = Bus(nes.prg_rom, pc_start);
    bus.fill_instr(0x8000);
    std::map<uint16_t, std::string> known_lables;
    std::map<uint16_t, std::string> macros;
    known_lables[pc_start] = "reset";
    known_lables[nmi] = "nmi";

    macros.insert(std::make_pair(0x2000, "PPU_CTRL"));
    macros.insert(std::make_pair(0x2001, "PPU_MASK"));
    macros.insert(std::make_pair(0x2002, "PPU_STATUS"));
    macros.insert(std::make_pair(0x2003, "OAM_ADDR"));
    macros.insert(std::make_pair(0x2004, "OAM_DATA"));
    macros.insert(std::make_pair(0x2005, "PPU_SCROLL"));
    macros.insert(std::make_pair(0x2006, "PPU_ADDR"));
    macros.insert(std::make_pair(0x2007, "PPU_DATA"));

    macros.insert(std::make_pair(0x4014, "OAM_DMA"));
    macros.insert(std::make_pair(0x4016, "JOYPAD1_BYTE"));
    macros.insert(std::make_pair(0x4017, "JOYPAD2_BYTE"));

    DisAsmState dis = {bus, known_lables, false, 0, macros};

    dis.bus.add_to_queue(nmi);

    // first thing we do is walk the PC.
    // get all the addresses that will be visited, by the PC and create a data strcuture of it
    auto prg = computer(dis);

    // since we have the data strcuture. what we do next is gather all the addresses that wont be visited
    //  we create ".define bytes" for them in the macro assembler.
    int highestpc = getHighestPC(nes);
    printf("%x \n", highestpc);

    for (int i = 0; (i + 0x8000) <= (highestpc); i++)
    {
        if (dis.bus.pc_visited.find((i + 0x8000)) == dis.bus.pc_visited.end())
        {
            prg.push_back(std::make_shared<DefinedByte>(nes.prg_rom[i], (i + 0x8000) + 1));
        }
    }

    // macros for the different addresses the NES uses.
    // makes the code more readable

    for (const auto &pair : dis.macros)
    {
        uint16_t addr = pair.first;
        std::string n = pair.second;
        prg.push_back(std::make_shared<Macro>(n, addr, 0));
        // std::cout << pc << std::endl;
    }
    // after that we add the lables.
    for (const auto &pair : dis.known_lables)
    {
        uint16_t pc = pair.first;
        std::string n = pair.second;
        prg.push_back(std::make_shared<Label>(n, pc + 1));
        // std::cout << pc << std::endl;
    }
    // sort by PC
    qsort_pc(prg, 0, prg.size() - 1);

    // print/write to file :p
    if (o.print_file)
    {
        std::cout << h.disassm() << std::endl;
        std::cout << ".SEGMENT \"VECTORS\"" << std::endl;
        std::cout << "      .addr reset" << std::endl;
        std::cout << "      .addr nmi" << std::endl;
        std::cout << ".SEGMENT \"STARTUP\" " << std::endl;

        for (int i = 0; i < prg.size(); i++)
        {

            std::cout << prg[i]->disassm();
        }
        std::cout << ".SEGMENT \"CHARS\" " << std::endl;
        if (o.chr_file.has_value())
            std::cout << ".incbin  \"" << o.chr_file.value() << "\" \n";
    }
    if (o.output_files.has_value())
    {
        std::ofstream outputFile(o.output_files.value());
        outputFile << h.disassm();
        outputFile << ".SEGMENT \"VECTORS\" \n";
        outputFile << ".addr nmi \n";
        outputFile << ".addr reset \n";
        outputFile << ".SEGMENT \"STARTUP\" \n";
        for (int i = 0; i < prg.size(); i++)
        {

            outputFile << prg[i]->disassm();
        }
        outputFile << ".SEGMENT \"CHARS\" \n";

        if (o.chr_file.has_value())
        {
            outputFile << ".incbin  \"" << o.chr_file.value() << "\" ; the sprites \n";
        }

        outputFile.close();
    }
    if (o.chr_file.has_value())
    {
        std::ofstream outputFile(o.chr_file.value());
        for (int i = 0; i < nes.chr_rom.size(); i++)
        {
            outputFile << nes.chr_rom[i];
        }
        outputFile.close();
    }
    std::cout << "nesda: \033[32mSuccessfully disassembled \033[0m" << std::endl;
}